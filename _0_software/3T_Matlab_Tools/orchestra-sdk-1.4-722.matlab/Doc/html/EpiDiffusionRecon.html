
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>EpiDiffusionRecon</title><meta name="generator" content="MATLAB 8.1"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2014-07-27"><meta name="DC.source" content="EpiDiffusionRecon.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, tt, code { font-size:12px; }
pre { margin:0px 0px 20px; }
pre.error { color:red; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#2">EpiDiffusionRecon</a></li><li><a href="#3">Determine secondary input locations</a></li><li><a href="#4">Load or process reference data</a></li><li><a href="#5">Load VRGF interpolation kernels</a></li><li><a href="#6">Initialize workspace and header variables</a></li><li><a href="#7">Load Asset Calibration (if applicable)</a></li><li><a href="#9">Determine T2 or BValue/Direction Indices</a></li><li><a href="#11">Apply Realtime Field Adjustment, if enabled</a></li><li><a href="#12">Finalization</a></li></ul></div><pre class="codeinput"><span class="keyword">function</span> [ finalImages ] = EpiDiffusionRecon(pfileFullPath)
</pre><h2>EpiDiffusionRecon<a name="2"></a></h2><p>Copyright 2014 General Electric Company. All rights reserved. GE Proprietary and Confidential Information. Only to be distributed with permission from GE. Resulting outputs are not for diagnostic purposes.</p><pre class="language-matlab">Reconstruct <span class="string">Epi</span> <span class="string">Diffusion</span> <span class="string">data</span> <span class="string">from</span> <span class="string">the</span> <span class="string">given</span> <span class="string">pfile.</span> <span class="string">For</span> <span class="string">scans</span> <span class="string">with</span>
multiple <span class="string">pfiles</span>, supply <span class="string">the</span> <span class="string">first</span> <span class="string">pfile</span> <span class="string">and</span> <span class="string">the</span> <span class="string">subsequent</span> <span class="string">pfiles</span> <span class="string">will</span>
automatically <span class="string">be</span> <span class="string">opened.</span>
This <span class="string">script</span> <span class="string">will</span> <span class="string">reconstruct</span> <span class="string">each</span> <span class="string">B-Value/Diffusion</span> <span class="string">Direction</span> <span class="string">acquired</span>
in <span class="string">the</span> <span class="string">Epi</span> <span class="string">Diffusion</span> <span class="string">scan.</span> <span class="string">This</span> <span class="string">script</span> <span class="string">does</span> <span class="string">not</span> <span class="string">generate</span> <span class="string">combined</span>
diffusion <span class="string">images.</span>
If <span class="string">this</span> <span class="string">diffusion</span> <span class="string">scan</span> <span class="string">was</span> <span class="string">acquired</span> <span class="string">with</span> <span class="string">an</span> <span class="string">integrated</span> <span class="string">reference</span> <span class="string">scan</span>,
then <span class="string">the</span> <span class="string">reference</span> <span class="string">data</span> <span class="string">acquired</span> <span class="string">during</span> <span class="string">the</span> <span class="string">first</span> <span class="string">phase</span> <span class="string">of</span> <span class="string">the</span> <span class="string">scan</span>
will <span class="string">be</span> <span class="string">used</span> <span class="string">to</span> <span class="string">compute</span> <span class="string">phase</span> <span class="string">correction</span> <span class="string">coefficients.</span> <span class="string">If</span> <span class="string">this</span> <span class="string">scan</span> <span class="string">was</span>
not <span class="string">acquired</span> <span class="string">with</span> <span class="string">an</span> <span class="string">integreated</span> <span class="string">reference</span> <span class="string">scan</span> <span class="string">then</span> <span class="string">this</span> <span class="string">script</span> <span class="string">will</span>
look (in the following order) <span class="keyword">for</span> the following <span class="string">sources</span> <span class="string">of</span> <span class="string">reference</span>
data: ref.h5 in <span class="string">pfile</span> <span class="string">directory</span>, ref.dat in <span class="string">pfile</span> <span class="string">directory</span>, reference
pfile <span class="string">in</span> <span class="string">pfileDirectory/ref/Prrrrr.7.</span>
</pre><pre class="language-matlab">finalImages = EpiDiffusionRecon(pfile)
</pre><h2>Determine secondary input locations<a name="3"></a></h2><p>Find the vrgf.dat or vrgf_kernels.dat file containing the ramp sampling interpolation kernels to use with this scan. This code will look in the pfile directory for either of these two files.</p><pre class="codeinput">    [pfilePath pfileName pfileExt] = fileparts(pfileFullPath);

    <span class="comment">% Look for vrgf data</span>
    vrgfDotDatPath = fullfile(pfilePath, <span class="string">'vrgf.dat'</span>);
    vrgfKernelsDotDatPath = fullfile(pfilePath, <span class="string">'vrgf_kernels.dat'</span>);
    <span class="keyword">if</span>(exist(vrgfDotDatPath, <span class="string">'file'</span>) == 2)
        <span class="comment">% Found vrgf.dat, use for vrgf interpolation kernels</span>
        vrgfInterpKernels = vrgfDotDatPath;
        vrgfEnabled = 1;
    <span class="keyword">elseif</span>(exist(vrgfKernelsDotDatPath, <span class="string">'file'</span>) == 2)
        <span class="comment">% Look for vrgf_kernels.dat</span>
        vrgfInterpKernels = vrgfKernelsDotDatPath;
        vrgfEnabled = 1;
    <span class="keyword">else</span>
        <span class="comment">% Could not find vrgf interpolation kernels!</span>
        disp(<span class="string">'Could not find vrgf interpolation kernels.'</span>);
        disp(<span class="string">'vrgf interpolation is disabled.'</span>);
        vrgfEnabled = 0;
    <span class="keyword">end</span>

    <span class="comment">% Load pfile and determine if asset was enabled for this scan</span>
    pfileHandle = GERecon(<span class="string">'Pfile.Load'</span>, pfileFullPath);
    header = GERecon(<span class="string">'Pfile.Header'</span>);

    <span class="comment">% Look for AssetCalibration. Note that if you have a calibration pfile</span>
    <span class="comment">% you can generate the AssetCalibration.h5 file using this command:</span>
    <span class="comment">%</span>
    <span class="comment">%   GERecon('Calibration.Process', 'pathToCalPfile/Pxxxxx.7').</span>
    <span class="comment">%</span>
    <span class="comment">% The calibration HDF5 file will be saved in the calibration pfile's</span>
    <span class="comment">% directory.</span>
    assetCalibrationPath = fullfile(pfilePath, <span class="string">'AssetCalibration.h5'</span>);
    assetEnabled = (header.RawHeader.asset == 2 || header.RawHeader.asset == 7);
    <span class="keyword">if</span>(exist(assetCalibrationPath, <span class="string">'file'</span>) == 2 &amp;&amp; assetEnabled)
        useAsset = 1;
        assetCalibration = assetCalibrationPath;
    <span class="keyword">else</span>
        useAsset = 0;
    <span class="keyword">end</span>
</pre><h2>Load or process reference data<a name="4"></a></h2><p>Integrated reference scan is indicated by rhref == 5. If this condition is true then set the referenceData variable to the first pfile in the scan. This pfile will be passed to the EpiComputeAndApplyPhaseCorrection function. If this is not an integrated reference scan then determine where the reference data can be obtained. The reference data may be supplied as a ref.dat file, a ref.h5 file, or a separate reference scan pfile.</p><pre class="codeinput">    <span class="comment">% Determine where the reference data can be obtained</span>
    <span class="keyword">if</span>(header.RawHeader.ref == 5)
       referenceData = pfileFullPath;
       firstImageAcquisitionPhase = 2;
    <span class="keyword">else</span>
       <span class="comment">% Reference data must be from either a ref.dat/ref.h5 file or a</span>
       <span class="comment">% separate reference scan.</span>
       refDotDatPath = fullfile(pfilePath, <span class="string">'ref.dat'</span>);
       refDotH5Path = fullfile(pfilePath, <span class="string">'ref.h5'</span>);
       refPfilePath = fullfile(pfilePath, <span class="string">'ref'</span>, [pfileName pfileExt]);
       <span class="keyword">if</span>(exist(refDotDatPath, <span class="string">'file'</span>) == 2)
           referenceData = refDotDatPath;
       <span class="keyword">elseif</span>(exist(refDotH5Path, <span class="string">'file'</span>) == 2)
           referenceData = refDotH5Path;
       <span class="keyword">elseif</span>(exist(refPfilePath, <span class="string">'file'</span>) == 2)
           referenceData = refPfilePath;
       <span class="keyword">end</span>
       firstImageAcquisitionPhase = 1;
    <span class="keyword">end</span>

    <span class="comment">% Load or process the reference data. For an integrated reference scan</span>
    <span class="comment">% or a scan with a separate reference scan pfile supplied, compute</span>
    <span class="comment">% phase correction coefficients. If ref.dat or ref.h5 is supplied, load</span>
    <span class="comment">% the coefficients from the given file.</span>
    <span class="keyword">if</span>(strcmp(<span class="string">'.7'</span>, referenceData(end-1:end)))
        <span class="comment">% Reference pfile was provided, load that and compute coefficients</span>
        phaseCorrectionHandle = EpiComputeAndApplyPhaseCorrection(referenceData);
    <span class="keyword">else</span>
        <span class="comment">% ref.dat or ref.h5 was provided, load the reference data file</span>
        phaseCorrectionHandle = GERecon(<span class="string">'Epi.LoadReference'</span>, referenceData);
    <span class="keyword">end</span>
</pre><h2>Load VRGF interpolation kernels<a name="5"></a></h2><p>VRGF (variable readout gradient filtering) refers to sampling data on the gradient ramps during data acquisition. During recon, a sinc interpolation is performed to interpolate non-linearly sampled frequency data (i.e. data sampled on the gradient ramps) to linearly sampled frequency data. The sinc interpolation kernels that are used for each point in the interpolated output are contained in a vrgf.dat for Epi Diffusion scans.</p><pre class="codeinput">    <span class="keyword">if</span>(vrgfEnabled == 1)
        vrgfHandle = GERecon(<span class="string">'RampSampling.Load'</span>, vrgfInterpKernels);
        kernelMatrix = GERecon(<span class="string">'RampSampling.KernelMatrix'</span>, vrgfHandle);
        figure;
        subplot(2,1,1);
        imagesc(kernelMatrix);colormap(gray);colorbar;axis <span class="string">off</span>;title(<span class="string">'VRGF Interpolation Kernel Matrix'</span>);
        subplot(2,1,2);
        numRows = size(kernelMatrix, 1);
        plot(kernelMatrix(numRows/4, :));title([<span class="string">'Sinc Interpolation Kernel for Interpolated Point: '</span> num2str(numRows/4) <span class="string">' of '</span> num2str(numRows)]);
    <span class="keyword">end</span>
</pre><img vspace="5" hspace="5" src="EpiDiffusionRecon_01.png" alt=""> <h2>Initialize workspace and header variables<a name="6"></a></h2><p>Pull values from the raw header and use these values to allocate space for intermediate data.</p><pre class="codeinput">    GERecon(<span class="string">'Pfile.SetActive'</span>, pfileHandle);
    header = GERecon(<span class="string">'Pfile.Header'</span>);
    imageSize = header.RawHeader.im_size;
    channelImages = single(zeros(imageSize, imageSize, pfileHandle.channels));
    finalImages = int16(zeros(imageSize, imageSize, (pfileHandle.slices*pfileHandle.phases)));
</pre><h2>Load Asset Calibration (if applicable)<a name="7"></a></h2><p>If the user specified an Asset calibration file, load the file and use Asset for channel combination.</p><pre class="codeinput">    <span class="keyword">if</span>(useAsset == 1)
        GERecon(<span class="string">'Asset.LoadCalibration'</span>, assetCalibration);
    <span class="keyword">end</span>

    <span class="comment">% Initialize image number to zero and begin looping over all phases</span>
    <span class="comment">% and slices. Each B-Value/Diffusion Direction combination is a</span>
    <span class="comment">% separate phase in the scan</span>
    finalImageFigure = figure;
    imageNumber = 0;
    <span class="keyword">for</span> phase = firstImageAcquisitionPhase:pfileHandle.phases
</pre><h2>Determine T2 or BValue/Direction Indices<a name="9"></a></h2><p>The following code is for product EPI diffusion sequences. Product sequences acquire the diffusion data in the following order (for X number of B-Values and Y number of directions per B-Value):</p><div><ul><li>Reference Phase (if integrated ref scan)</li><li>T2 Phase(s)</li><li>B0, Dir0</li><li>B0, Dir1</li><li>...</li><li>BX, Dir0</li><li>BX, DirY</li></ul></div><p>The BValue and direction indices may be used to generate combined images for each B-Value (combined image generation is not included in this example).</p><pre class="codeinput">        numBValues = header.RawHeader.numbvals;
        numDiffusionDirections = header.RawHeader.numdifdirs;
        numT2Images = pfileHandle.phases - (numBValues * numDiffusionDirections) - (firstImageAcquisitionPhase-1);
        isT2Phase = phase &lt; (numT2Images + firstImageAcquisitionPhase);
        <span class="keyword">if</span>(isT2Phase)
            currentNexCount = header.RawHeader.difnext2;
        <span class="keyword">else</span>
            currentBValueIndex = floor((phase - firstImageAcquisitionPhase - numT2Images) / numDiffusionDirections) + 1;
            currentNexCount = header.RawHeader.difnextab(currentBValueIndex);
            <span class="comment">% currentDirectionIndex = mod((phase - firstImageAcquisitionPhase - numT2Images), numDiffusionDirections) + 1;</span>
        <span class="keyword">end</span>

        <span class="keyword">for</span> slice = 1:pfileHandle.slices
</pre><pre class="codeinput">            corners = GERecon(<span class="string">'Pfile.Corners'</span>, slice);
            orientation = GERecon(<span class="string">'Pfile.Orientation'</span>, slice);

            <span class="comment">% Initialize space for NEX'd magnitude image to zero.</span>
            <span class="comment">% Epi diffusion scans use the echo index as the NEX index.</span>
            magnitudeImage = zeros(imageSize, imageSize);

            <span class="comment">% If complex image nex'ing is enabled, accumulate nex'd data on</span>
            <span class="comment">% a channel by channel basis. The output will be an</span>
            <span class="comment">% accumulated kSpace matrix for each channel. This accumulated</span>
            <span class="comment">% channel data is used by the remaining recon steps as if</span>
            <span class="comment">% this were a single nex scan.</span>
            complexNexEnabled = bitget(header.RawHeader.data_collect_type1, 26);
            <span class="keyword">if</span>(complexNexEnabled &gt; 0)
                complexNexCount = currentNexCount;
                magnitudeNexCount = 1;
            <span class="keyword">else</span>
                complexNexCount = 1;
                magnitudeNexCount = currentNexCount;
            <span class="keyword">end</span>

            <span class="keyword">if</span>(complexNexEnabled &gt; 0)
                magnitudeNexCount = 1;
                complexNexChannelData = zeros(header.RawHeader.vrgfxres, header.RawHeader.da_yres - 1, pfileHandle.channels);

                <span class="keyword">for</span> channel = 1:pfileHandle.channels
                    <span class="keyword">for</span> echo = 1:complexNexCount
                        <span class="comment">% Retrieve input kSpace</span>
                        kSpace = GERecon(<span class="string">'Pfile.KSpace'</span>, slice, echo, channel, phase);

                        <span class="comment">% Apply phase correction</span>
                        phaseCorrectedKSpace = GERecon(<span class="string">'Epi.ApplyPhaseCorrection'</span>, phaseCorrectionHandle, kSpace, slice, channel);

                        <span class="keyword">if</span>(vrgfEnabled == 1)
                            <span class="comment">% Interpolate ramp sampled data and accumulate</span>
                            <span class="comment">% into complex nex combiner</span>
                            interpolatedData = GERecon(<span class="string">'RampSampling.Interpolate'</span>, vrgfHandle, phaseCorrectedKSpace);
                            GERecon(<span class="string">'Epi.ComplexImageNex'</span>, interpolatedData);
                        <span class="keyword">else</span>
                            <span class="comment">% No ramp sampling interpolation to do,</span>
                            <span class="comment">% accumulate into nex comnbiner</span>
                            GERecon(<span class="string">'Epi.ComplexImageNex'</span>, phaseCorrectedKSpace);
                        <span class="keyword">end</span>
                    <span class="keyword">end</span>

                    complexNexChannelData(:,:,channel) = GERecon(<span class="string">'Epi.ComplexImageNex'</span>);
                <span class="keyword">end</span>
            <span class="keyword">end</span>

            <span class="keyword">for</span> echo=1:magnitudeNexCount
                <span class="keyword">for</span> channel=1:pfileHandle.channels

                    <span class="comment">% If complex image nex is enabled then phase correction</span>
                    <span class="comment">% and ramp sampling interpolation was done above.</span>
                    <span class="comment">% Retrieve the dataToTransform from the complex nex</span>
                    <span class="comment">% channel data that was processed above.</span>
                    <span class="keyword">if</span>(complexNexEnabled)
                        dataToTransform = complexNexChannelData(:,:,channel);
                    <span class="keyword">else</span>
                        kSpace = GERecon(<span class="string">'Pfile.KSpace'</span>, slice, echo, channel, phase);

                        <span class="comment">% Apply phase correction</span>
                        phaseCorrectedKSpace = GERecon(<span class="string">'Epi.ApplyPhaseCorrection'</span>, phaseCorrectionHandle, kSpace, slice, channel);

                        <span class="comment">% Interpolate ramp sampled data</span>
                        <span class="keyword">if</span>(vrgfEnabled == 1)
                            dataToTransform = GERecon(<span class="string">'RampSampling.Interpolate'</span>, vrgfHandle, phaseCorrectedKSpace);
                        <span class="keyword">else</span>
                            dataToTransform = phaseCorrectedKSpace;
                        <span class="keyword">end</span>
                    <span class="keyword">end</span>

                    image = GERecon(<span class="string">'Transform'</span>, dataToTransform);

                    <span class="comment">% If ASSET and Homodyne are both enabled for this scan</span>
                    <span class="comment">% then ASSET is run on both the high pass filtered and</span>
                    <span class="comment">% low pass filtered images generated by the Homodyne</span>
                    <span class="comment">% algorithm. To enable this use case, the Transform</span>
                    <span class="comment">% command returns the high pass filtered and low pass</span>
                    <span class="comment">% filtered images in indices one and two of the third</span>
                    <span class="comment">% dimension of the return image. For this case, the</span>
                    <span class="comment">% channel images array must have space to store the</span>
                    <span class="comment">% additional high pass filtered / low pass filtered</span>
                    <span class="comment">% images. Resize the channelImages matrix here to</span>
                    <span class="comment">% enable this use case. Note that this resize happens</span>
                    <span class="comment">% only once, the first time through this loop.</span>
                    <span class="keyword">if</span>( (size(image,3) &gt; 1) &amp;&amp; (size(channelImages,4) == 1) )
                        channelImages = single(zeros(size(channelImages,1), size(channelImages,2), size(channelImages,3), 2));
                    <span class="keyword">end</span>

                    channelImages(:,:,channel,:) = image;
                <span class="keyword">end</span>

                <span class="comment">% ASSET Unalias</span>
                <span class="keyword">if</span>(useAsset)
                    channelCombinedImage = GERecon(<span class="string">'Asset.Unalias'</span>, channelImages, corners);
                <span class="keyword">else</span>
                    channelCombinedImage = GERecon(<span class="string">'SumOfSquares'</span>, channelImages);
                <span class="keyword">end</span>

                <span class="comment">% Accumulate magnitude NEX's</span>
                magnitudeImage = magnitudeImage + abs(channelCombinedImage);
            <span class="keyword">end</span>

            magnitudeImage = magnitudeImage / magnitudeNexCount;

            <span class="comment">% Zero out kissoff views prior to realtime field adjustment and</span>
            <span class="comment">% gradwarp (matches product functionality).</span>
            kissoffViews = header.RawHeader.kissoff_views;
            magnitudeImage(:,1:kissoffViews) = 0;
            magnitudeImage(:,(end-kissoffViews+1):end) = 0;
</pre><h2>Apply Realtime Field Adjustment, if enabled<a name="11"></a></h2><p>Realtime field adjustment interpolates image data along the phase encoding direction to compensate for eddy currents that exist when the diffusion gradients are turned on. This utility will use the slice and phase indices to determine how much compensation to apply for the current slice based on the slice location and diffusion gradient strength for the current phase. Note that scans acquired without realtime field adjustment enabled lack the information required in the raw header to apply this correction. Thus, only scans acquired with realtime field adjustment enabled can take advantage of this utility</p><pre class="codeinput">            <span class="keyword">if</span>(header.RawHeader.hoecc &gt; 0)
                <span class="comment">% Apply Realtime Field Adjustment</span>
                fieldAdjusted = GERecon(<span class="string">'Epi.RealtimeFieldAdjustment'</span>, magnitudeImage, slice, phase);
            <span class="keyword">else</span>
                <span class="comment">% Do not apply Realtime Field Adjustment</span>
                fieldAdjusted = magnitudeImage;
            <span class="keyword">end</span>
</pre><h2>Finalization<a name="12"></a></h2><p>Apply gradwarp, orient image, scale and convert to shorts prior to creating a DICOM image for this slice</p><pre class="codeinput">            gradwarpImage = GERecon(<span class="string">'Gradwarp'</span>, fieldAdjusted, corners, <span class="string">'XRMW'</span>);

            <span class="comment">% Partial ky homodyne scans have additional scaling applied at</span>
            <span class="comment">% the end of recon (match product scaling here)</span>
            partialKyHomodyne = bitget(header.RawHeader.data_collect_type, 5);
            <span class="keyword">if</span>(partialKyHomodyne)
                gradwarpImage = gradwarpImage * (256 / (header.RawHeader.rc_xres * header.RawHeader.rc_yres));
            <span class="keyword">end</span>

            <span class="comment">% Orient Image</span>
            rotatedTransposedSlice = GERecon(<span class="string">'Orient'</span>, gradwarpImage, orientation);
            rotatedTransposedCorners = GERecon(<span class="string">'Orient'</span>, corners, orientation);

            <span class="comment">% Clip to range of shorts (match product functionality)</span>
            rotatedTransposedSlice(rotatedTransposedSlice &lt; 0) = 0;
            rotatedTransposedSlice(rotatedTransposedSlice &gt; 32767) = 32767;
            finalImages(:,:,imageNumber+1) = int16(rotatedTransposedSlice);

            figure(finalImageFigure);
            imagesc(finalImages(:,:,imageNumber+1));colormap(gray);colorbar;axis <span class="string">off</span>;title([<span class="string">'Slice: '</span> num2str(slice) <span class="string">'Phase: '</span> num2str(phase)]);
            drawnow;

            <span class="keyword">if</span>(imageNumber &lt; 10)
                imageNumberString = [<span class="string">'00'</span> num2str(imageNumber)];
            <span class="keyword">elseif</span>(imageNumber &lt; 100)
                imageNumberString = [<span class="string">'0'</span> num2str(imageNumber)];
            <span class="keyword">else</span>
                imageNumberString = num2str(imageNumber);
            <span class="keyword">end</span>

            matlabDicomPath = fullfile(pfilePath, <span class="string">'matlabDicoms'</span>, filesep);

            <span class="comment">% Diffusion Image Type Annotation</span>
            <span class="comment">% Possible Values:</span>
            <span class="comment">%   DiffusionRightLeftDicomValue = 3</span>
            <span class="comment">%   DiffusionAnteriorPosteriorDicomValue = 4</span>
            <span class="comment">%   DiffusionSuperiorInferiorDicomValue = 5</span>
            <span class="comment">%   DiffusionT2DicomValue = 14</span>
            <span class="comment">%   DiffusionCombinedDicomValue = 15</span>
            <span class="comment">%   DiffusionDtiDicomValue = 16</span>
            <span class="comment">%   DiffusionDirection1DicomValue = 43</span>
            <span class="comment">%   DiffusionDirection2DicomValue = 44</span>
            <span class="comment">%   DiffusionDirection3DicomValue = 45</span>
            <span class="comment">%   DiffusionDirection4DicomValue = 46</span>
            <span class="comment">% The diffusion image type is not in the pool header. Thus,</span>
            <span class="comment">% the diffusion image type must come from an external source.</span>
            <span class="comment">% By default, the diffusion image type is set to Dir 1.</span>
            diffusionImageTypeTag.Group = hex2dec(<span class="string">'0043'</span>);
            diffusionImageTypeTag.Element = hex2dec(<span class="string">'1030'</span>);
            diffusionImageTypeTag.VRType = <span class="string">'SS'</span>;
            diffusionImageTypeTag.Value = 43;

            <span class="comment">% 1-based geometric index of slice</span>
            geometricIndexTag.Group = hex2dec(<span class="string">'0020'</span>);
            geometricIndexTag.Element = hex2dec(<span class="string">'9057'</span>);
            geometricIndexTag.VRType = <span class="string">'UL'</span>;
            geometricIndexTag.Value = slice;

            <span class="comment">% BValue Bias Factor</span>
            <span class="comment">% Product DICOM images have a bias factor of 1e9 added to the</span>
            <span class="comment">% bValue dicom field (first integer in 0043,1039) for scans</span>
            <span class="comment">% with more than one bValue. The bias factor, if applied, is</span>
            <span class="comment">% stored in DICOM field (0043,107f). The bias factor</span>
            <span class="comment">% functionality is replicated here.</span>
            <span class="comment">% The bValue is not present in the pfile header. Thus, the</span>
            <span class="comment">% bValue must come from another external source. By default,</span>
            <span class="comment">% the bValue is set to 0.</span>
            bValue = 0;
            bValueTag.Group = hex2dec(<span class="string">'0043'</span>);
            bValueTag.Element = hex2dec(<span class="string">'1039'</span>);
            bValueTag.VRType = <span class="string">'IS'</span>;
            bValueTag.Value = [num2str(bValue) <span class="string">'\ 0 \ 0 \ 0'</span>];

            <span class="keyword">if</span>(numBValues &gt; 1)
                <span class="comment">% Update bValue tag to include bias factor and include</span>
                <span class="comment">% b-Value bias factor in dicom image header.</span>
                bValueBiasFactor = 1000000000;
                bValue = bValue + bValueBiasFactor;
                bValueTag.Value = [num2str(bValue) <span class="string">'\ 0 \ 0 \ 0'</span>];

                bValueBiasFactorTag.Group = hex2dec(<span class="string">'0043'</span>);
                bValueBiasFactorTag.Element = hex2dec(<span class="string">'107f'</span>);
                bValueBiasFactorTag.VRType = <span class="string">'IS'</span>;
                bValueBiasFactorTag.Value = num2str(bValueBiasFactor);

                GERecon(<span class="string">'Dicom.Write'</span>, [matlabDicomPath <span class="string">'Image_'</span> imageNumberString <span class="string">'.dcm'</span>], finalImages(:,:,imageNumber+1), imageNumber, orientation, <span class="keyword">...</span>
                        rotatedTransposedCorners, (header.SeriesData.se_no*100), header.SeriesData.se_desc, diffusionImageTypeTag, geometricIndexTag, bValueTag, bValueBiasFactorTag);
            <span class="keyword">else</span>
                GERecon(<span class="string">'Dicom.Write'</span>, [matlabDicomPath <span class="string">'Image_'</span> imageNumberString <span class="string">'.dcm'</span>], finalImages(:,:,imageNumber+1), imageNumber, orientation, <span class="keyword">...</span>
                        rotatedTransposedCorners, (header.SeriesData.se_no*100), header.SeriesData.se_desc, diffusionImageTypeTag, geometricIndexTag, bValueTag);
            <span class="keyword">end</span>

            imageNumber = imageNumber + 1;
</pre><img vspace="5" hspace="5" src="EpiDiffusionRecon_02.png" alt=""> <img vspace="5" hspace="5" src="EpiDiffusionRecon_03.png" alt=""> <img vspace="5" hspace="5" src="EpiDiffusionRecon_04.png" alt=""> <img vspace="5" hspace="5" src="EpiDiffusionRecon_05.png" alt=""> <img vspace="5" hspace="5" src="EpiDiffusionRecon_06.png" alt=""> <img vspace="5" hspace="5" src="EpiDiffusionRecon_07.png" alt=""> <img vspace="5" hspace="5" src="EpiDiffusionRecon_08.png" alt=""> <img vspace="5" hspace="5" src="EpiDiffusionRecon_09.png" alt=""> <img vspace="5" hspace="5" src="EpiDiffusionRecon_10.png" alt=""> <img vspace="5" hspace="5" src="EpiDiffusionRecon_11.png" alt=""> <img vspace="5" hspace="5" src="EpiDiffusionRecon_12.png" alt=""> <img vspace="5" hspace="5" src="EpiDiffusionRecon_13.png" alt=""> <img vspace="5" hspace="5" src="EpiDiffusionRecon_14.png" alt=""> <img vspace="5" hspace="5" src="EpiDiffusionRecon_15.png" alt=""> <img vspace="5" hspace="5" src="EpiDiffusionRecon_16.png" alt=""> <img vspace="5" hspace="5" src="EpiDiffusionRecon_17.png" alt=""> <img vspace="5" hspace="5" src="EpiDiffusionRecon_18.png" alt=""> <img vspace="5" hspace="5" src="EpiDiffusionRecon_19.png" alt=""> <pre class="codeinput">        <span class="keyword">end</span>
</pre><pre class="codeinput">    <span class="keyword">end</span>
</pre><pre class="codeinput"><span class="keyword">end</span>
</pre><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2013a</a><br></p></div><!--
##### SOURCE BEGIN #####
function [ finalImages ] = EpiDiffusionRecon(pfileFullPath)
%% EpiDiffusionRecon
%
% Copyright 2014 General Electric Company. All rights reserved.
% GE Proprietary and Confidential Information. Only to be distributed with
% permission from GE. Resulting outputs are not for diagnostic purposes.
%   
%   Reconstruct Epi Diffusion data from the given pfile. For scans with
%   multiple pfiles, supply the first pfile and the subsequent pfiles will
%   automatically be opened.
%   This script will reconstruct each B-Value/Diffusion Direction acquired
%   in the Epi Diffusion scan. This script does not generate combined
%   diffusion images.
%   If this diffusion scan was acquired with an integrated reference scan,
%   then the reference data acquired during the first phase of the scan
%   will be used to compute phase correction coefficients. If this scan was
%   not acquired with an integreated reference scan then this script will
%   look (in the following order) for the following sources of reference
%   data: ref.h5 in pfile directory, ref.dat in pfile directory, reference
%   pfile in pfileDirectory/ref/Prrrrr.7.
%
%   finalImages = EpiDiffusionRecon(pfile)
%

    %% Determine secondary input locations
    % Find the vrgf.dat or vrgf_kernels.dat file containing the ramp
    % sampling interpolation kernels to use with this scan. This code will
    % look in the pfile directory for either of these two files.
    [pfilePath pfileName pfileExt] = fileparts(pfileFullPath);

    % Look for vrgf data
    vrgfDotDatPath = fullfile(pfilePath, 'vrgf.dat');
    vrgfKernelsDotDatPath = fullfile(pfilePath, 'vrgf_kernels.dat');
    if(exist(vrgfDotDatPath, 'file') == 2)
        % Found vrgf.dat, use for vrgf interpolation kernels
        vrgfInterpKernels = vrgfDotDatPath;
        vrgfEnabled = 1;
    elseif(exist(vrgfKernelsDotDatPath, 'file') == 2)
        % Look for vrgf_kernels.dat        
        vrgfInterpKernels = vrgfKernelsDotDatPath;    
        vrgfEnabled = 1;
    else
        % Could not find vrgf interpolation kernels!
        disp('Could not find vrgf interpolation kernels.');
        disp('vrgf interpolation is disabled.');
        vrgfEnabled = 0;
    end
    
    % Load pfile and determine if asset was enabled for this scan
    pfileHandle = GERecon('Pfile.Load', pfileFullPath);
    header = GERecon('Pfile.Header');

    % Look for AssetCalibration. Note that if you have a calibration pfile
    % you can generate the AssetCalibration.h5 file using this command:
    %
    %   GERecon('Calibration.Process', 'pathToCalPfile/Pxxxxx.7').
    %
    % The calibration HDF5 file will be saved in the calibration pfile's
    % directory.
    assetCalibrationPath = fullfile(pfilePath, 'AssetCalibration.h5');
    assetEnabled = (header.RawHeader.asset == 2 || header.RawHeader.asset == 7);
    if(exist(assetCalibrationPath, 'file') == 2 && assetEnabled)
        useAsset = 1;
        assetCalibration = assetCalibrationPath;
    else
        useAsset = 0;
    end

    %% Load or process reference data    
    % Integrated reference scan is indicated by rhref == 5. If this
    % condition is true then set the referenceData variable to the first
    % pfile in the scan. This pfile will be passed to the
    % EpiComputeAndApplyPhaseCorrection function. 
    % If this is not an integrated reference scan then determine where the
    % reference data can be obtained. The reference data may be supplied 
    % as a ref.dat file, a ref.h5 file, or a separate reference scan pfile.    
    
    % Determine where the reference data can be obtained
    if(header.RawHeader.ref == 5)
       referenceData = pfileFullPath;
       firstImageAcquisitionPhase = 2;
    else
       % Reference data must be from either a ref.dat/ref.h5 file or a 
       % separate reference scan.
       refDotDatPath = fullfile(pfilePath, 'ref.dat');
       refDotH5Path = fullfile(pfilePath, 'ref.h5');
       refPfilePath = fullfile(pfilePath, 'ref', [pfileName pfileExt]);
       if(exist(refDotDatPath, 'file') == 2)
           referenceData = refDotDatPath;
       elseif(exist(refDotH5Path, 'file') == 2)
           referenceData = refDotH5Path;
       elseif(exist(refPfilePath, 'file') == 2)
           referenceData = refPfilePath;
       end       
       firstImageAcquisitionPhase = 1;
    end
    
    % Load or process the reference data. For an integrated reference scan
    % or a scan with a separate reference scan pfile supplied, compute
    % phase correction coefficients. If ref.dat or ref.h5 is supplied, load
    % the coefficients from the given file.
    if(strcmp('.7', referenceData(end-1:end)))
        % Reference pfile was provided, load that and compute coefficients
        phaseCorrectionHandle = EpiComputeAndApplyPhaseCorrection(referenceData);    
    else       
        % ref.dat or ref.h5 was provided, load the reference data file
        phaseCorrectionHandle = GERecon('Epi.LoadReference', referenceData);        
    end
            
    %% Load VRGF interpolation kernels
    % VRGF (variable readout gradient filtering) refers to sampling data on
    % the gradient ramps during data acquisition. During recon, a sinc
    % interpolation is performed to interpolate non-linearly sampled
    % frequency data (i.e. data sampled on the gradient ramps) to linearly
    % sampled frequency data.
    % The sinc interpolation kernels that are used for each point in the 
    % interpolated output are contained in a vrgf.dat for Epi Diffusion
    % scans.
    if(vrgfEnabled == 1)
        vrgfHandle = GERecon('RampSampling.Load', vrgfInterpKernels);    
        kernelMatrix = GERecon('RampSampling.KernelMatrix', vrgfHandle);
        figure;
        subplot(2,1,1);
        imagesc(kernelMatrix);colormap(gray);colorbar;axis off;title('VRGF Interpolation Kernel Matrix');
        subplot(2,1,2);
        numRows = size(kernelMatrix, 1);
        plot(kernelMatrix(numRows/4, :));title(['Sinc Interpolation Kernel for Interpolated Point: ' num2str(numRows/4) ' of ' num2str(numRows)]);   
    end
            
    %% Initialize workspace and header variables
    % Pull values from the raw header and use these values to allocate
    % space for intermediate data.
    GERecon('Pfile.SetActive', pfileHandle);
    header = GERecon('Pfile.Header');
    imageSize = header.RawHeader.im_size;
    channelImages = single(zeros(imageSize, imageSize, pfileHandle.channels));    
    finalImages = int16(zeros(imageSize, imageSize, (pfileHandle.slices*pfileHandle.phases)));        
    
    %% Load Asset Calibration (if applicable)
    % If the user specified an Asset calibration file, load the file and
    % use Asset for channel combination.
    if(useAsset == 1)
        GERecon('Asset.LoadCalibration', assetCalibration);    
    end     
    
    % Initialize image number to zero and begin looping over all phases 
    % and slices. Each B-Value/Diffusion Direction combination is a
    % separate phase in the scan
    finalImageFigure = figure;
    imageNumber = 0;     
    for phase = firstImageAcquisitionPhase:pfileHandle.phases
       
        %% Determine T2 or BValue/Direction Indices
        % The following code is for product EPI diffusion sequences.
        % Product sequences acquire the diffusion data in the
        % following order (for X number of B-Values and Y number of
        % directions per B-Value):
        %
        % * Reference Phase (if integrated ref scan)
        % * T2 Phase(s)
        % * B0, Dir0
        % * B0, Dir1
        % * ...
        % * BX, Dir0
        % * BX, DirY
        %
        % The BValue and direction indices may be used to generate combined
        % images for each B-Value (combined image generation is not 
        % included in this example).
        numBValues = header.RawHeader.numbvals;
        numDiffusionDirections = header.RawHeader.numdifdirs;
        numT2Images = pfileHandle.phases - (numBValues * numDiffusionDirections) - (firstImageAcquisitionPhase-1);
        isT2Phase = phase < (numT2Images + firstImageAcquisitionPhase);
        if(isT2Phase)            
            currentNexCount = header.RawHeader.difnext2;
        else            
            currentBValueIndex = floor((phase - firstImageAcquisitionPhase - numT2Images) / numDiffusionDirections) + 1;         
            currentNexCount = header.RawHeader.difnextab(currentBValueIndex);
            % currentDirectionIndex = mod((phase - firstImageAcquisitionPhase - numT2Images), numDiffusionDirections) + 1;
        end
                                      
        for slice = 1:pfileHandle.slices
            
            corners = GERecon('Pfile.Corners', slice);
            orientation = GERecon('Pfile.Orientation', slice);            
            
            % Initialize space for NEX'd magnitude image to zero.
            % Epi diffusion scans use the echo index as the NEX index.
            magnitudeImage = zeros(imageSize, imageSize);
            
            % If complex image nex'ing is enabled, accumulate nex'd data on
            % a channel by channel basis. The output will be an 
            % accumulated kSpace matrix for each channel. This accumulated
            % channel data is used by the remaining recon steps as if 
            % this were a single nex scan.
            complexNexEnabled = bitget(header.RawHeader.data_collect_type1, 26); 
            if(complexNexEnabled > 0)
                complexNexCount = currentNexCount;
                magnitudeNexCount = 1;
            else
                complexNexCount = 1;
                magnitudeNexCount = currentNexCount;                
            end
            
            if(complexNexEnabled > 0)
                magnitudeNexCount = 1;
                complexNexChannelData = zeros(header.RawHeader.vrgfxres, header.RawHeader.da_yres - 1, pfileHandle.channels);
                
                for channel = 1:pfileHandle.channels
                    for echo = 1:complexNexCount
                        % Retrieve input kSpace                        
                        kSpace = GERecon('Pfile.KSpace', slice, echo, channel, phase);    
                        
                        % Apply phase correction
                        phaseCorrectedKSpace = GERecon('Epi.ApplyPhaseCorrection', phaseCorrectionHandle, kSpace, slice, channel);

                        if(vrgfEnabled == 1)
                            % Interpolate ramp sampled data and accumulate
                            % into complex nex combiner
                            interpolatedData = GERecon('RampSampling.Interpolate', vrgfHandle, phaseCorrectedKSpace);                        
                            GERecon('Epi.ComplexImageNex', interpolatedData);
                        else
                            % No ramp sampling interpolation to do, 
                            % accumulate into nex comnbiner
                            GERecon('Epi.ComplexImageNex', phaseCorrectedKSpace);
                        end
                    end
                    
                    complexNexChannelData(:,:,channel) = GERecon('Epi.ComplexImageNex');
                end
            end
            
            for echo=1:magnitudeNexCount
                for channel=1:pfileHandle.channels
                    
                    % If complex image nex is enabled then phase correction
                    % and ramp sampling interpolation was done above.
                    % Retrieve the dataToTransform from the complex nex
                    % channel data that was processed above.
                    if(complexNexEnabled)
                        dataToTransform = complexNexChannelData(:,:,channel);
                    else                                                
                        kSpace = GERecon('Pfile.KSpace', slice, echo, channel, phase);

                        % Apply phase correction
                        phaseCorrectedKSpace = GERecon('Epi.ApplyPhaseCorrection', phaseCorrectionHandle, kSpace, slice, channel);

                        % Interpolate ramp sampled data
                        if(vrgfEnabled == 1)
                            dataToTransform = GERecon('RampSampling.Interpolate', vrgfHandle, phaseCorrectedKSpace);                        
                        else
                            dataToTransform = phaseCorrectedKSpace;
                        end
                    end
                                        
                    image = GERecon('Transform', dataToTransform);
                    
                    % If ASSET and Homodyne are both enabled for this scan
                    % then ASSET is run on both the high pass filtered and
                    % low pass filtered images generated by the Homodyne
                    % algorithm. To enable this use case, the Transform
                    % command returns the high pass filtered and low pass
                    % filtered images in indices one and two of the third
                    % dimension of the return image. For this case, the
                    % channel images array must have space to store the
                    % additional high pass filtered / low pass filtered
                    % images. Resize the channelImages matrix here to
                    % enable this use case. Note that this resize happens
                    % only once, the first time through this loop.
                    if( (size(image,3) > 1) && (size(channelImages,4) == 1) )
                        channelImages = single(zeros(size(channelImages,1), size(channelImages,2), size(channelImages,3), 2));
                    end
                    
                    channelImages(:,:,channel,:) = image;
                end
                
                % ASSET Unalias
                if(useAsset)
                    channelCombinedImage = GERecon('Asset.Unalias', channelImages, corners);
                else                
                    channelCombinedImage = GERecon('SumOfSquares', channelImages);
                end     
                
                % Accumulate magnitude NEX's
                magnitudeImage = magnitudeImage + abs(channelCombinedImage);                
            end
            
            magnitudeImage = magnitudeImage / magnitudeNexCount;
            
            % Zero out kissoff views prior to realtime field adjustment and
            % gradwarp (matches product functionality).
            kissoffViews = header.RawHeader.kissoff_views;
            magnitudeImage(:,1:kissoffViews) = 0;
            magnitudeImage(:,(end-kissoffViews+1):end) = 0;
            
            %% Apply Realtime Field Adjustment, if enabled
            % Realtime field adjustment interpolates image data along the
            % phase encoding direction to compensate for eddy currents that
            % exist when the diffusion gradients are turned on. This
            % utility will use the slice and phase indices to determine 
            % how much compensation to apply for the current slice based 
            % on the slice location and diffusion gradient strength for 
            % the current phase.
            % Note that scans acquired without realtime field adjustment
            % enabled lack the information required in the raw header to
            % apply this correction. Thus, only scans acquired with
            % realtime field adjustment enabled can take advantage of this
            % utility
            if(header.RawHeader.hoecc > 0) 
                % Apply Realtime Field Adjustment
                fieldAdjusted = GERecon('Epi.RealtimeFieldAdjustment', magnitudeImage, slice, phase);
            else
                % Do not apply Realtime Field Adjustment
                fieldAdjusted = magnitudeImage;
            end            
            
            %% Finalization
            % Apply gradwarp, orient image, scale and convert to shorts
            % prior to creating a DICOM image for this slice
            gradwarpImage = GERecon('Gradwarp', fieldAdjusted, corners, 'XRMW');           
            
            % Partial ky homodyne scans have additional scaling applied at
            % the end of recon (match product scaling here)
            partialKyHomodyne = bitget(header.RawHeader.data_collect_type, 5);
            if(partialKyHomodyne)                
                gradwarpImage = gradwarpImage * (256 / (header.RawHeader.rc_xres * header.RawHeader.rc_yres));
            end

            % Orient Image
            rotatedTransposedSlice = GERecon('Orient', gradwarpImage, orientation);
            rotatedTransposedCorners = GERecon('Orient', corners, orientation);

            % Clip to range of shorts (match product functionality)            
            rotatedTransposedSlice(rotatedTransposedSlice < 0) = 0;
            rotatedTransposedSlice(rotatedTransposedSlice > 32767) = 32767;
            finalImages(:,:,imageNumber+1) = int16(rotatedTransposedSlice);

            figure(finalImageFigure);
            imagesc(finalImages(:,:,imageNumber+1));colormap(gray);colorbar;axis off;title(['Slice: ' num2str(slice) 'Phase: ' num2str(phase)]);
            drawnow;

            if(imageNumber < 10)
                imageNumberString = ['00' num2str(imageNumber)];
            elseif(imageNumber < 100)
                imageNumberString = ['0' num2str(imageNumber)];
            else
                imageNumberString = num2str(imageNumber);
            end

            matlabDicomPath = fullfile(pfilePath, 'matlabDicoms', filesep);
            
            % Diffusion Image Type Annotation
            % Possible Values:
            %   DiffusionRightLeftDicomValue = 3
            %   DiffusionAnteriorPosteriorDicomValue = 4
            %   DiffusionSuperiorInferiorDicomValue = 5
            %   DiffusionT2DicomValue = 14
            %   DiffusionCombinedDicomValue = 15
            %   DiffusionDtiDicomValue = 16
            %   DiffusionDirection1DicomValue = 43
            %   DiffusionDirection2DicomValue = 44
            %   DiffusionDirection3DicomValue = 45
            %   DiffusionDirection4DicomValue = 46
            % The diffusion image type is not in the pool header. Thus, 
            % the diffusion image type must come from an external source.
            % By default, the diffusion image type is set to Dir 1.
            diffusionImageTypeTag.Group = hex2dec('0043');
            diffusionImageTypeTag.Element = hex2dec('1030');
            diffusionImageTypeTag.VRType = 'SS';
            diffusionImageTypeTag.Value = 43;
            
            % 1-based geometric index of slice
            geometricIndexTag.Group = hex2dec('0020');
            geometricIndexTag.Element = hex2dec('9057');
            geometricIndexTag.VRType = 'UL';
            geometricIndexTag.Value = slice;
            
            % BValue Bias Factor
            % Product DICOM images have a bias factor of 1e9 added to the
            % bValue dicom field (first integer in 0043,1039) for scans
            % with more than one bValue. The bias factor, if applied, is
            % stored in DICOM field (0043,107f). The bias factor
            % functionality is replicated here.
            % The bValue is not present in the pfile header. Thus, the
            % bValue must come from another external source. By default,
            % the bValue is set to 0.
            bValue = 0;
            bValueTag.Group = hex2dec('0043');
            bValueTag.Element = hex2dec('1039');
            bValueTag.VRType = 'IS';   
            bValueTag.Value = [num2str(bValue) '\ 0 \ 0 \ 0'];            
                        
            if(numBValues > 1)
                % Update bValue tag to include bias factor and include
                % b-Value bias factor in dicom image header.
                bValueBiasFactor = 1000000000;
                bValue = bValue + bValueBiasFactor;                
                bValueTag.Value = [num2str(bValue) '\ 0 \ 0 \ 0'];
                
                bValueBiasFactorTag.Group = hex2dec('0043');
                bValueBiasFactorTag.Element = hex2dec('107f');
                bValueBiasFactorTag.VRType = 'IS';   
                bValueBiasFactorTag.Value = num2str(bValueBiasFactor);

                GERecon('Dicom.Write', [matlabDicomPath 'Image_' imageNumberString '.dcm'], finalImages(:,:,imageNumber+1), imageNumber, orientation, ...
                        rotatedTransposedCorners, (header.SeriesData.se_no*100), header.SeriesData.se_desc, diffusionImageTypeTag, geometricIndexTag, bValueTag, bValueBiasFactorTag);                
            else
                GERecon('Dicom.Write', [matlabDicomPath 'Image_' imageNumberString '.dcm'], finalImages(:,:,imageNumber+1), imageNumber, orientation, ...
                        rotatedTransposedCorners, (header.SeriesData.se_no*100), header.SeriesData.se_desc, diffusionImageTypeTag, geometricIndexTag, bValueTag);
            end            

            imageNumber = imageNumber + 1;            
        end            
    end
end


##### SOURCE END #####
--></body></html>